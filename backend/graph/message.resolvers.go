package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/roglau/WEB-RA-231/graph/model"
)

// CreateConversation is the resolver for the createConversation field.
func (r *mutationResolver) CreateConversation(ctx context.Context, inputConversation model.NewConversations) (bool, error) {
	if inputConversation.Group {
		// Logic for group conversation
		conversation := &model.Conversations{
			ID:        uuid.NewString(),
			User1id:   "",
			User2id:   inputConversation.User2id,
			Group:     inputConversation.Group,
			CreatedAt: time.Now().Format("2006-01-02 15:04:05"),
		}

		if err := r.DB.Save(&conversation).Error; err != nil {
			return false, err
		}

		conversationDetail := &model.ConversationDetails{
			ID:             uuid.NewString(),
			ConversationID: conversation.ID,
			UserID:         inputConversation.User1id,
		}

		if err := r.DB.Save(&conversationDetail).Error; err != nil {
			return false, err
		}

		for _, user := range inputConversation.Users {
			conversationDetail := &model.ConversationDetails{
				ID:             uuid.NewString(),
				ConversationID: conversation.ID,
				UserID:         user,
			}

			if err := r.DB.Save(&conversationDetail).Error; err != nil {
				return false, err
			}
		}

		return true, nil
	}

	// Logic for non-group conversation
	conversation := &model.Conversations{
		ID:        uuid.NewString(),
		User1id:   inputConversation.User1id,
		User2id:   inputConversation.User2id,
		Group:     inputConversation.Group,
		CreatedAt: time.Now().Format("2006-01-02 15:04:05"),
	}

	if err := r.DB.Save(&conversation).Error; err != nil {
		return false, err
	}

	return true, nil
}

// CreateMessage is the resolver for the createMessage field.
func (r *mutationResolver) CreateMessage(ctx context.Context, inputMessage model.NewMessages, medias []string) (*model.Messages, error) {
	message := &model.Messages{
		ID:             uuid.NewString(),
		ConversationID: inputMessage.ConversationID,
		SenderID:       inputMessage.SenderID,
		Content:        inputMessage.Content,
		CreatedAt:      time.Now().Format("2006-01-02 15:04:05"),
		HasMedia:       inputMessage.HasMedia,
	}

	if err := r.DB.Save(&message).Error; err != nil {
		return nil, err
	}

	var msgWMedia *model.MsgWMedia
	var mediaUrls []string

	if message.HasMedia && len(medias) > 0 {
		for _, media := range medias {
			mediaUrls = append(mediaUrls, media)
			inputMedia := model.NewPostMedia{
				PostID: message.ID,
				Media:  media,
			}
			if _, err := r.CreatePostMedia(ctx, inputMedia); err != nil {
				return nil, err
			}
		}
	}

	msgWMedia = &model.MsgWMedia{
		Message: message,
		Medias:  mediaUrls,
	}

	for _, conn := range r.Conns {
		fmt.Println(conn)
		err := conn.WriteJSON(&msgWMedia)
		if err != nil {
			fmt.Println(err)
		}
	}

	return message, nil
}

// GetAllConversation is the resolver for the getAllConversation field.
func (r *queryResolver) GetAllConversation(ctx context.Context, userID string) ([]*model.ConversationsWMsg, error) {
	var conversations []*model.Conversations

	if err := r.DB.Where("user1id = ? OR user2id = ?", userID, userID).Find(&conversations).Error; err != nil {
		return nil, err
	}

	var conversationsWMsg []*model.ConversationsWMsg

	for _, conv := range conversations {
		var msgWMedia []*model.MsgWMedia
		var messages []*model.Messages
		if err := r.DB.Where("conversation_id", conv.ID).Find(&messages).Error; err != nil {
			return nil, err
		}

		for _, msg := range messages {
			var mediaURLs []string
			if msg.HasMedia {
				var media []model.PostMedia
				if err := r.DB.Where("post_id", msg.ID).Find(&media).Error; err != nil {
					return nil, err
				}
				for _, m := range media {
					mediaURLs = append(mediaURLs, m.Media)
				}
			}
			msgWMedia = append(msgWMedia, &model.MsgWMedia{
				Message: msg,
				Medias:  mediaURLs,
			})
		}

		var interlocutorID string
		if conv.User1id != userID {
			interlocutorID = conv.User1id
		} else {
			interlocutorID = conv.User2id
		}

		var interlocutor *model.User
		var users []*model.User
		if err := r.DB.Where("id", interlocutorID).First(&interlocutor).Error; err != nil {
			return nil, err
		}

		conversationsWMsg = append(conversationsWMsg, &model.ConversationsWMsg{
			Conversation:  conv,
			Messages:      msgWMedia,
			Interlocutor:  interlocutor,
			Interlocutors: users,
		})

	}

	var groupConversations []*model.Conversations

	if err := r.DB.Where("\"group\" = ?", true).Find(&groupConversations).Error; err != nil {
		return nil, err
	}

	for _, header := range groupConversations {
		var msgWMedia []*model.MsgWMedia
		var groupConversationDetails []*model.ConversationDetails

		var messages []*model.Messages
		if err := r.DB.Where("conversation_id = ?", header.ID).Find(&messages).Error; err != nil {
			return nil, err
		}

		if err := r.DB.Where("conversation_id = ?", header.ID).Find(&groupConversationDetails).Error; err != nil {
			return nil, err
		}

		for _, msg := range messages {
			var mediaURLs []string
			if msg.HasMedia {
				var media []model.PostMedia
				if err := r.DB.Where("post_id", msg.ID).Find(&media).Error; err != nil {
					return nil, err
				}
				for _, m := range media {
					mediaURLs = append(mediaURLs, m.Media)
				}
			}
			msgWMedia = append(msgWMedia, &model.MsgWMedia{
				Message: msg,
				Medias:  mediaURLs,
			})
		}

		var users []*model.User
		for _, detail := range groupConversationDetails {
			if detail.UserID != userID {
				user, err := r.Query().GetUser(ctx, detail.UserID)

				if err != nil {
					return nil, err
				}

				users = append(users, &model.User{
					ID:        user.ID,
					Email:     user.Email,
					Firstname: user.Firstname,
					Surname:   user.Surname,
					Dob:       user.Dob,
					Gender:    user.Gender,
					Activated: user.Activated,
					Profile:   user.Profile,
				})

			}
		}

		userIsInGroup := false
		for _, detail := range groupConversationDetails {
			if detail.UserID == userID {
				userIsInGroup = true
				break
			}
		}

		if userIsInGroup {
			var interlocutor *model.User
			conversationsWMsg = append(conversationsWMsg, &model.ConversationsWMsg{
				Conversation:  header,
				Messages:      msgWMedia,
				Interlocutors: users,
				Interlocutor:  interlocutor,
			})
		}
	}
	return conversationsWMsg, nil
}

// GetConversation is the resolver for the getConversation field.
func (r *queryResolver) GetConversation(ctx context.Context, convID string, userID string) (*model.ConversationsWMsg, error) {
	var conversations *model.Conversations

	if err := r.DB.Where("id = ?", convID).Find(&conversations).Error; err != nil {
		return nil, err
	}

	if !conversations.Group {
		var msgWMedia []*model.MsgWMedia
		var messages []*model.Messages
		if err := r.DB.Where("conversation_id", convID).Find(&messages).Error; err != nil {
			return nil, err
		}

		for _, msg := range messages {
			var mediaURLs []string
			if msg.HasMedia {
				var media []model.PostMedia
				if err := r.DB.Where("post_id", msg.ID).Find(&media).Error; err != nil {
					return nil, err
				}
				for _, m := range media {
					mediaURLs = append(mediaURLs, m.Media)
				}
			}
			msgWMedia = append(msgWMedia, &model.MsgWMedia{
				Message: msg,
				Medias:  mediaURLs,
			})
		}

		var interlocutorID string
		if conversations.User1id != userID {
			interlocutorID = conversations.User1id
		} else {
			interlocutorID = conversations.User2id
		}

		var interlocutor *model.User
		var users []*model.User
		if err := r.DB.Where("id", interlocutorID).First(&interlocutor).Error; err != nil {
			return nil, err
		}

		conversationsWMsg := &model.ConversationsWMsg{
			Conversation:  conversations,
			Messages:      msgWMedia,
			Interlocutor:  interlocutor,
			Interlocutors: users,
		}

		return conversationsWMsg, nil
	} else {
		var msgWMedia []*model.MsgWMedia
		var groupConversationDetails []*model.ConversationDetails

		var messages []*model.Messages
		if err := r.DB.Where("conversation_id = ?", convID).Find(&messages).Error; err != nil {
			return nil, err
		}

		if err := r.DB.Where("conversation_id = ?", convID).Find(&groupConversationDetails).Error; err != nil {
			return nil, err
		}

		for _, msg := range messages {
			var mediaURLs []string
			if msg.HasMedia {
				var media []model.PostMedia
				if err := r.DB.Where("post_id", msg.ID).Find(&media).Error; err != nil {
					return nil, err
				}
				for _, m := range media {
					mediaURLs = append(mediaURLs, m.Media)
				}
			}
			msgWMedia = append(msgWMedia, &model.MsgWMedia{
				Message: msg,
				Medias:  mediaURLs,
			})
		}

		var users []*model.User
		for _, detail := range groupConversationDetails {
			if detail.UserID != userID {
				user, err := r.Query().GetUser(ctx, detail.UserID)

				if err != nil {
					return nil, err
				}

				users = append(users, &model.User{
					ID:        user.ID,
					Email:     user.Email,
					Firstname: user.Firstname,
					Surname:   user.Surname,
					Dob:       user.Dob,
					Gender:    user.Gender,
					Activated: user.Activated,
					Profile:   user.Profile,
				})

			}
		}

		userIsInGroup := false
		for _, detail := range groupConversationDetails {
			if detail.UserID == userID {
				userIsInGroup = true
				break
			}
		}

		if userIsInGroup {
			var interlocutor *model.User
			conversationsWMsg := &model.ConversationsWMsg{
				Conversation:  conversations,
				Messages:      msgWMedia,
				Interlocutor:  interlocutor,
				Interlocutors: users,
			}

			return conversationsWMsg, nil
		}
	}
	return nil, nil
}
